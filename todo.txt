TODO:
test expression parsing:
-redundant std::move in constructor?
-right now, we parse one one-line expressions, one on each line. these are compiled into statements.

error reporting
-to report which line we're on, we may need a data structure that takes a token num and returns its line num and position within that line (maybe just a vector containing the line starts indices. we can perform a binary search to get the line and subtraction to get the distance from beginning of the line.
-errors are reported immediately, followed by syncing.

synchronization
add assignment
add if statement
add while statement

-have a category enumeration for each individual operator (so you don't have to check both value and category)
-better error reporting for lexer
-remember to remove whitespaces for the output of getline
-make sure we don't throw std::exception, but throw a derived object.

-make sure '-' can be used as a unary operator ('-1')
-make sure any number of minuses can be stacked (---1 == -1, 5--1 == 6)
-make sure any number of pluses can be stacked as well.

future features:
-support for floats (not just integers)
-throw an exception class that has the problematic line, the position, and the index (see how the python ui throws errors)
-ctrl+C to KeyboardInterrupt (terminate a running script). run on another thread.
-augassign (augmented assignment statements): +=, -=, etc. (see grammar for the rest)
-chaining assignment (NAME '=')+ annotated_rhs
-pass, break, and continue statements
-for_stmt
-booleans: 'True', 'False'
-strings as an atom
-python indent rules. indents can be arbitrary in length, but the ensuing block must have that same number of indents. nested blocks must have a longer indent than the surrounding block. thus, track the length of the indents for a block. (question: how does 

notes:
-max int representation is not [int min, int max], but (int min, int max]. This is because the negative sign and the digits are treated separately in intermediate stages, and the absolute value must be storable into a normal int.

--------

reset symbol table when switching between inlin

ideally, expevaluator returns the symbol table

Execution -> file, tokens, symbol table


Execution from_interface
Execution from_file



-only one execution at a time.
-if we run inline, and the current execution is not inline

Execution current_execution; -> symbol table, file_lines, file_tokens

Execution is std::variant<InterfaceExecution, FileExecution>

// when we run inline (and curr_execution.type == File), we clear data, i.e. replace with a new object
// when we run a file and curr_execution.type == Interface, we delete also clear data.
--for interface, we gather the lines, get tokens, and do curr_execution.RunCode(tokens)
--for a file, we call 'read', which creates a new execution and stores the lines and tokens (curr_execution.SetFile(lines), and call curr_execution.RunFile(), which is a wrapper for RunCode(file_tokens)
---maybe "Read" should be in the execution (so curr_execution.ReadFile, curr_execution.GetFileLines, curr_execution.GetTokens, curr_execution.Run)

maybe we *do* use inheritance. so Execution -> FileExecution and InterfaceExecution. Execution has a symbol table and RunCode(tokens). The children do private inheritance, so that RunCode(tokens) cannot be called from the user. InterfaceExecution has RunLines(tokens), which just calls RunCode(tokens). FileExecution only has RunFile().
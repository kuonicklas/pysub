// PARSER
class Parser{
public:
	GetAST();
	CheckSyntax(tokens);	// non-allocating parse
	BuildTree(tokens);	// allocating parse
	
private:
	Parse(tokens);	// CheckSyntax and BuildTree call this
	bool is_allocating
	AST syntax_tree{}
	std::vector<Token> token_stream;
	std::iterator curr_token;

	BuildTree(){
		syntax_tree = AST();
	}
	AST(){
		if (!eof){
			return AST{Statements()};
		}
		return AST{};	
	}
	Statements(){
		std::vector<Statement> statements{};
		statements.push_back(Statement());	// at least one
		while (!eof){
			statements.push_back(Statement());
		}
		return statements;
	}
	StatementType Statement(){
		if (MatchCompoundStatement()){
			return CompoundStatement();
		}
		else if (MatchSimpleStatement()){
			return SimpleStatement();
		}
	}
	SimpleStatement(){
		if (match(NAME, '=')){
			return Assignment();
		}
		return Expression();
	}
}

class AST{
	std::vector<Statement> statements{};
}

void CheckSyntax(tokens){
	is_allocating = false;
	Parse();
}

void BuildTree(tokens){
	is_allocating = true;
	Parse();
}

void Parse(tokens){
	
}





class Statement{
	
}
class CompoundStatement : public Statement{
	
}
class SimpleStatement : public Statement{
	
}
class Assignment : public SimpleStatement{
	
}

std::vector<Statement>
while (!eof){
	Statement new_statement = Statement();
	Store(Statement);
	if (allocate){
		vector.push_back(new_statement);
	}
}
return 

STORE:
if (is_allocating):
	vec.push_back(statement);